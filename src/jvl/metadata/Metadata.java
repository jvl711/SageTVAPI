
package jvl.metadata;

import java.io.IOException;
import jvl.sage.SageCallApiException;
import jvl.sage.api.Show;
import jvl.tmdb.SearchAPI;
import jvl.tmdb.TMDBRequest;
import jvl.tmdb.model.Movie;
import jvl.tmdb.model.SearchResults;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Date;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import jvl.logging.Logging;
import jvl.sage.api.Configuration;
import jvl.tmdb.ConfigAPI;
import jvl.tmdb.MovieAPI;
import jvl.tmdb.RateLimitException;
import jvl.tmdb.TVAPI;
import jvl.tmdb.model.Credits;
import jvl.tmdb.model.Episode;
import jvl.tmdb.model.Image;
import jvl.tmdb.model.Images;
import jvl.tmdb.model.MovieReleases;
import jvl.tmdb.model.Season;
import jvl.tmdb.model.TV;

/***
 * This class is used for managing metadata for show objects in SageTV.  It associates
 * metadata based on a Movie Title/Year or a Show title and episode number.  This
 * does not store metadata based on MediaFile object.  The data can persist and be
 * shared among different SageTV instances.
 * 
 * The class is based on The Movie Database.  I choose to do that since it was a
 * one stop for both TV and Movies, and is a crowd source database, where anyone 
 * can contribute.
 * 
 * @author jvl711
 */
public class Metadata 
{
    private File cacheFolder;
    private File dataFolder;
    private Show show;
    private TMDBRequest request;
    
    /*Basic cache for lookup on title*/
    private static Map<String, Integer> TMDBIDCacheMovie = new ConcurrentHashMap<String, Integer>();
    private static Map<String, Integer> TMDBIDCacheTV = new ConcurrentHashMap<String, Integer>();
    
    private static final int DEFAULT_POSTER_SIZE_WIDTH = 600;
    private static final int DEFAULT_STILL_SIZE_WIDTH = 600;
    private static final int DEFAULT_BACKDROP_SIZE_WIDTH = 3840;
    
    private static final Logger LOG = Logging.getLogger(Metadata.class.getName());
    
    /***
     * Creates a default instance of the Metadata class for a show 
     * with default directories ([working directory]\metadata, [working directory]\metacache).  
     * Metacache directory stores information looked up from TMDB.  Metadata is meant to
     * store data generated by the user.  For instance, watched state of a show.
     * @param show The show to look up metadata for 
     */
    public Metadata(Show show, String apikey)
    {
        this("metacache", "metadata", show, apikey);
    }
    
    /***
     * Creates an instance of the Metadata class for a show 
     * with where directories ([working directory]\metadata, [working directory]\metacache) 
     * can be defined different than the defaults. Metacache directory stores 
     * information looked up from TMDB.  Metadata is meant to store data generated by the user.  
     * For instance, watched state of a show.
     * @param cacheFolder The cache folder for data looked up from TMDB
     * @param dataFolder The data folder to store static user generated 
     * info about shows/movies
     * @param show The show to look up metadata for 
     */
    public Metadata(String cacheFolder, String dataFolder, Show show, String apikey)
    {
        this.cacheFolder = new File(cacheFolder);
        this.dataFolder = new File(dataFolder);
        this.show = show;
        this.request = new TMDBRequest(apikey);
        
        try
        {
            if(!this.dataFolder.exists())
            {
                this.dataFolder.mkdir();
            }
        }
        catch(Exception ex) 
        { 
            LOG.severe("Unable to create data directory for metadata");
            throw new RuntimeException("Unable to create data directory for metadata");
        }
        
        if(!this.dataFolder.canRead())
        {
            LOG.severe("Unable to read from the data directory for metadata");
            throw new RuntimeException("Unable to read from the data directory for metadata");
        }
        
        if(!this.dataFolder.canWrite())
        {
            LOG.severe("Unable to write from data directory for metadata");
            throw new RuntimeException("Unable to write from data directory for metadata");
        }
        
        try
        {
            if(!this.cacheFolder.exists())
            {
                this.cacheFolder.mkdir();
            }
        }
        catch(Exception ex) 
        { 
            LOG.severe("Unable to create cache directory for metadata");
            throw new RuntimeException("Unable to create cahace directory for metadata");
        }
        
        if(!this.cacheFolder.canRead())
        {
            LOG.severe("Unable to read from the cache directory for metadata");
            throw new RuntimeException("Unable to read from the cache directory for metadata");
        }
        
        if(!this.cacheFolder.canWrite())
        {
            LOG.severe("Unable to write from cache directory for metadata");
            throw new RuntimeException("Unable to write from cache directory for metadata");
        }
    }
    
    /***
     * Lookup metadata using TMDB and store the data into the metadata cache folder.
     * Use info from SageTV db if this is recorded content, otherwise use the filename
     * parser to attempt to determine the content
     * @param forceRefresh Lookup metadata even if there is already stored metadata
     * @param blocking Wait for the lookup to return before returning from the call
     * @return Returns true if the lookup was successful false otherwise
     * @throws SageCallApiException If there is an error making a SageTV API call
     * @throws IOException If there is an exception writing to the cache directory
     * or making a call to the TMDB web service
     * @throws RateLimitException TMDB enforces a number of calls per minute.  This 
     * exception will be thrown if that is exceeded
     */
    public boolean LookupMetadata(boolean forceRefresh, boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        LOG.log(Level.INFO, "LookupMetadata called on show title {0} with forceReresh: {1} and blocking: {2}", new Object[]{show.GetTitle(), forceRefresh, blocking});
           
        if(!this.HasMetadata() || forceRefresh)
        {
            if(this.show.GetMediaFile().IsTVFile() && !this.show.IsMovie()) //Recorded TV
            {
                LOG.log(Level.INFO, "This is recored content that is not a movie");
                
                int tmdb_id = -1;
                
                if(this.HasCachedTVTMDB_ID(show.GetTitle()))
                {
                    LOG.info("Metadata cache hit on title for TV Show id");
                    tmdb_id = this.GetCachedTVTMDB_ID(show.GetTitle());
                }
                else
                {
                    LOG.info("Not in metadata id cache.  Searching for TV show.");
                    SearchResults results = SearchAPI.searchTV(this.request, show.GetTitle(), blocking);
                    
                    if(results != null && results.getShows().size() > 0)
                    {
                        tmdb_id = results.getShows().get(0).getTmdbID();
                        this.PutCacheTVTMDB_ID(show.GetTitle(), tmdb_id);
                    }
                }

                if(tmdb_id > 0)
                {
                    LOG.info("Found show and saving metadata to cache");
                    if(show.GetEpisodeNumber() > 0)
                    {
                        this.SaveTVMetadata(tmdb_id, this.show.GetSeasonNumber(), this.show.GetEpisodeNumber(), forceRefresh, blocking);
                    }
                    else
                    {
                        //This is for shows that do not have season episode numbers
                        this.SaveTVMetadata(tmdb_id, blocking, forceRefresh);
                    }
                }
                else
                {
                    //TODO:  Think about logging this to the system message interface
                    LOG.log(Level.WARNING, "There was no hit looking up the tv show {0}", new Object[]{show.GetTitle()});
                    LOG.info("Going to set MediaType to TV and TMDBID to -2 so it is at available to view");
                    this.show.SetMediaType("TV");
                    this.show.SetTheMovieDBID(-2);

                    return false;
                }

                return false;
            }
            else if(this.show.GetMediaFile().IsTVFile() && this.show.IsMovie()) //Recored Movie
            {
                LOG.log(Level.INFO, "This is recored content that is a movie");
                
                SearchResults results;
                int year = 0;
                int tmdb_id = -1;
                try{ year = Integer.parseInt(this.show.GetYear()); } catch(Exception ex) { }                
                
                if(year > 0)
                {
                    if(this.HasCachedMovieTMDB_ID(this.show.GetTitle(), year))
                    {
                        LOG.info("Metadata cache hit getting movie id");
                        tmdb_id = this.GetCachedMovieTMDB_ID(this.show.GetTitle(), year);
                    }
                    else
                    {
                        LOG.info("Not in metadata id cache.  Searching for movie.");
                        
                        results = SearchAPI.searchMovies(this.request, this.show.GetTitle(), year, blocking);
                        
                        if(results != null && results.getMovies().size() > 0)
                        {
                            tmdb_id = results.getMovies().get(0).getTmdbID();
                            this.PutCacheMovieTMDB_ID(this.show.GetTitle(), year, tmdb_id);
                        }
                    }
                }
                else
                {
                    if(this.HasCachedMovieTMDB_ID(this.show.GetTitle()))
                    {
                        LOG.info("Metadata cache hit getting movie id");
                        tmdb_id = this.GetCachedMovieTMDB_ID(this.show.GetTitle());
                    }
                    else
                    {
                        results = SearchAPI.searchMovies(this.request, this.show.GetTitle(), blocking);
                        
                        if(results != null && results.getMovies().size() > 0)
                        {
                            tmdb_id = results.getMovies().get(0).getTmdbID();
                            this.PutCacheMovieTMDB_ID(this.show.GetTitle(), tmdb_id);
                        }
                    }
                }
                
                if(tmdb_id > 0)
                {
                    LOG.info("Found movie and saving metadata to cache");
                    this.SaveMovieMetadata(tmdb_id, forceRefresh, blocking);
                }
                else
                {
                    //TODO:  Think about logging this to the system message interface
                    LOG.log(Level.WARNING, "There was no hit looking up the movie {0}", new Object[]{show.GetTitle()});
                    LOG.info("Going to set MediaType to Movie and TMDBID to -2 so it is at available to view");
                    
                    this.show.SetMediaType("Movie");
                    this.show.SetTheMovieDBID(-2);
                    
                    return false;
                }

            }
            else //This is non-recorded content
            {
                LOG.log(Level.INFO, "Looking up metadata content by filename: {0}", new Object[]{this.show.GetMediaFile().GetFileName()});
                
                FileNameParser parser = new FileNameParser(this.show.GetMediaFile().GetFileName());
                
                SearchResults results;
                int tmdb_id = -1;
                
                if(parser.IsMovie())
                {
                    LOG.info("Filename parser identified content as a movie");
                    
                    if(parser.GetReleaseYear() > 0)
                    {
                        
                        if(this.HasCachedMovieTMDB_ID(parser.GetTitle(), parser.GetReleaseYear()))
                        {
                            LOG.info("Metadata cache hit getting movie id");
                            tmdb_id = this.GetCachedMovieTMDB_ID(parser.GetTitle(), parser.GetReleaseYear());
                        }
                        else
                        {
                            results = SearchAPI.searchMovies(this.request, parser.GetTitle(), parser.GetReleaseYear(), blocking);

                            if(results != null && results.getMovies().size() > 0)
                            {
                                tmdb_id = results.getMovies().get(0).getTmdbID();
                                this.PutCacheMovieTMDB_ID(parser.GetTitle(), parser.GetReleaseYear(), tmdb_id);
                            }
                        }
                    }
                    else
                    {
                        if(this.HasCachedMovieTMDB_ID(parser.GetTitle()))
                        {
                            LOG.info("Metadata cache hit getting movie id");
                            tmdb_id = this.GetCachedMovieTMDB_ID(parser.GetTitle());
                        }
                        else
                        {
                            results = SearchAPI.searchMovies(this.request, parser.GetTitle(), blocking);

                            if(results != null && results.getMovies().size() > 0)
                            {
                                tmdb_id = results.getMovies().get(0).getTmdbID();
                                this.PutCacheMovieTMDB_ID(parser.GetTitle(), tmdb_id);
                            }
                        }
                    }
                    
                    if(tmdb_id > 0)
                    {
                        LOG.info("Found movie and saving metadata to cache");
                        this.SaveMovieMetadata(tmdb_id, forceRefresh, blocking);
                    }
                    else
                    {
                        //TODO:  Think about logging this to the system message interface
                        LOG.log(Level.WARNING, "There was no hit looking up the movie {0}", new Object[]{show.GetTitle()});
                        LOG.info("Going to set MediaType to Movie and TMDBID to -2 so it is at available to view");
                        
                        return false;
                    }
                }
                else
                {
                    LOG.info("Filename parser thinks this is a tv show");
                    
                    if(this.HasCachedTVTMDB_ID(parser.GetTitle()))
                    {
                        tmdb_id = this.GetCachedTVTMDB_ID(parser.GetTitle());
                        LOG.info("Metadata cache hit getting tv id");
                    }
                    else
                    {
                        results = SearchAPI.searchTV(request, parser.GetTitle(), blocking);
                        
                        if(results != null && results.getShows().size() > 0)
                        {
                            tmdb_id = results.getShows().get(0).getTmdbID();
                            this.PutCacheTVTMDB_ID(parser.GetTitle(), tmdb_id);
                        }
                    }
                    
                    if(tmdb_id > 0)
                    {
                        LOG.info("Found movie and saving metadata to cache");
                        this.SaveTVMetadata(tmdb_id, parser.GetSeason(), parser.GetEpisode(), forceRefresh, blocking);
                    }
                    else
                    {
                        //TODO:  Think about logging this to the system message interface
                        LOG.log(Level.WARNING, "There was no hit looking up the tv show {0}", new Object[]{show.GetTitle()});
                        LOG.info("Going to set MediaType to TV and TMDBID to -2 so it is at available to view");
                        
                        return false;
                    }
                }
            }  
        }
        
        return true;
    }
    
    private void PutCacheMovieTMDB_ID(String title, int year, int tmdb_id)
    {
        LOG.log(Level.FINE, "Caching TMDBID for movie title: {0} year: {1} tmdb_id: {2}", new Object[]{title, year, tmdb_id});
        
        if(!Metadata.TMDBIDCacheMovie.containsKey(title + "_" + year))
        {
            Metadata.TMDBIDCacheMovie.put(title + "_" + year, tmdb_id);
        }
    }
    
    private void PutCacheMovieTMDB_ID(String title, int tmdb_id)
    {
        LOG.log(Level.FINE, "Caching TMDBID for movie title: {0} tmdb_id: {1}", new Object[]{title, tmdb_id});
        
        if(!Metadata.TMDBIDCacheMovie.containsKey(title))
        {
            Metadata.TMDBIDCacheMovie.put(title, tmdb_id);
        }
    }
    
    private boolean HasCachedMovieTMDB_ID(String title)
    {
        LOG.log(Level.FINE, "Checking if movie is in the cache title: {0}", title);
        boolean cacheHit = Metadata.TMDBIDCacheMovie.containsKey(title);
        LOG.log(Level.FINE, "Cache hit: {0}", cacheHit);
        return cacheHit;
    }
    
    private boolean HasCachedMovieTMDB_ID(String title, int year)
    {
        LOG.log(Level.FINE, "Checking if movie is in the cache title: {0}, year [1]", new Object[]{title, year});
        
        return Metadata.TMDBIDCacheMovie.containsKey(title + "_" + year);
    }
    
    private int GetCachedMovieTMDB_ID(String title, int year)
    {
        LOG.log(Level.FINE, "Getting cached TMDB for movie title: {0}, year [1]", new Object[]{title, year});
        
        return Metadata.TMDBIDCacheMovie.get(title + "_" + year);
    }
    
    private int GetCachedMovieTMDB_ID(String title)
    {
        LOG.log(Level.FINE, "Getting cached TMDB for movie title: {0}", title);
        
        return Metadata.TMDBIDCacheMovie.get(title);
    }
    
    private void PutCacheTVTMDB_ID(String title, int tmdb_id)
    {
        LOG.log(Level.FINE, "Adding cached TMDB for TV title: {0}", new Object[]{title});
        
        if(!Metadata.TMDBIDCacheTV.containsKey(title))
        {
            Metadata.TMDBIDCacheTV.put(title, tmdb_id);
        }
    }
    
    private boolean HasCachedTVTMDB_ID(String title)
    {
        LOG.log(Level.FINE, "Checking to see if the TV title is cached: {0}", new Object[]{title});
        return Metadata.TMDBIDCacheTV.containsKey(title);
    }
    
    private int GetCachedTVTMDB_ID(String title)
    {
        LOG.log(Level.FINE, "Getting cached ID for TV title: {0}", new Object[]{title});
        return Metadata.TMDBIDCacheTV.get(title);
    }
    
    /***
     * Saves key metadata to TV show, and manages cache and images for the show.
     * Will automatically retrieve any missing details for an episode.  Can force
     * a cache refresh if requested.
     * 
     * @param tmdb_id The Movie DB id for the TV show
     * @param seasonNumber Season Number of the show
     * @param episodeNumber Episode Number of the show
     * @param forceRefresh Force refresh even if the episode is cached 
     * @param blocking Wait for the lookups to return even if a rate limiting is hit
     * @throws IOException Error reading writing to file or TMDB web service
     * @throws SageCallApiException Error calling SageAPI 
     * @throws RateLimitException TMDB rate limit exception thrown
     */
    public void SaveTVMetadata(int tmdb_id, int seasonNumber, int episodeNumber, boolean forceRefresh, boolean blocking) throws IOException, SageCallApiException, RateLimitException
    {
        LOG.log(Level.INFO, "Saving TV show metadata tmdb_id: {0},seasonNumber: {1}, episodeNumber: {2}, forceRefresh: {3}, blocking: {4}", new Object[]{tmdb_id, seasonNumber, episodeNumber, forceRefresh, blocking});
        
        File detailsFile = this.GetTVDetailsFile(tmdb_id);
        File creditsFile = this.GetTVCreditsFile(tmdb_id);
        File imagesFile = this.GetTVImagesFile(tmdb_id);
        File seasonFile = this.GetTVSeasonFile(tmdb_id, seasonNumber);
        File seasonImagesFile = this.GetTVSeasonImagesFile(tmdb_id, seasonNumber);
        File episodeImagesFile = this.GetTVEpisodeImagesFile(tmdb_id, seasonNumber, episodeNumber);

        boolean updateCache = forceRefresh;
        
        //Check to see if we need to update files.  If we already have the season episode info
        //then skip.  If we are missing anything than update it all.
        if(!detailsFile.exists())
        {
            LOG.fine("Detail file does not exist, updating cache");
            updateCache = true; 
        }
        
        if(!creditsFile.exists()) 
        { 
            LOG.fine("Credits file does not exist, updating cache");
            updateCache = true; 
        }
        
        if(!imagesFile.exists()) 
        { 
            LOG.fine("Images file does not exist, updating cache");
            updateCache = true; 
        }
    
        if(!seasonFile.exists())
        { 
            LOG.fine("Season file does not exist, updating cache");
            updateCache = true; 
        }
        else
        {
            TV tv = TV.parse(detailsFile, ConfigAPI.getConfig(request, blocking));
            
            if(!tv.hasSeason(seasonNumber))
            {
                LOG.fine("Season file does not have the requested season, updating cache");
                updateCache = true;
            }
            else
            {
                Season season = Season.parse(seasonFile, ConfigAPI.getConfig(request, blocking));

                if(!season.hasEpisode(episodeNumber))
                {
                    LOG.fine("Season file does not have the requested episode, updating cache");
                    updateCache = true;
                }
            }
        }
                
        Date now = new Date();

        TV tv = null;
        Credits credits = null;
        Season season = null;
        Episode episode = null;
            
        if(updateCache)
        {
            LOG.fine("Getting TV show details from tmdb");
            tv = TVAPI.getDetails(this.request, tmdb_id, blocking);
            
            if(tv == null)
            {
                return;
            }
            
            LOG.fine("Getting TV show credits from tmdb");
            credits = TVAPI.getCredits(request, tmdb_id, blocking);
            
            try
            {
                LOG.fine("Getting TV show season details from tmdb");
                season = TVAPI.getSeasonDetails(this.request, tmdb_id, seasonNumber, blocking);

                if(season != null)
                {
                    LOG.fine("Getting TV show episode details from season");
                    episode = season.getEpisode(episodeNumber);
                }
            }
            catch(Exception ex)
            {
                //Season info is not always up to date.  Allow to fail and still continue to update
                LOG.warning("Error updating season/episode details.  Allowing metadata update to continue");
            }
            
        }
        else
        {
            LOG.fine("Cache files exist.  Parsing existing cache");
            tv = TV.parse(detailsFile, ConfigAPI.getConfig(request, blocking));
            season = Season.parse(seasonFile, ConfigAPI.getConfig(request, blocking));
            episode = season.getEpisode(episodeNumber);
        }

        
        LOG.fine("Setting metadata key data onto show, and setting MediaType to TV");
        show.SetTheMovieDBID(tmdb_id);
        show.SetEpisodeNumber(episodeNumber);
        show.SetSeasonNumber(seasonNumber);
        show.SetMetadataUpdateDate(now.getTime());
        show.SetMediaType("TV");
        
        if(tv != null)
        {
            LOG.fine("Setting title and Catefories/Genres onto show");
            show.SetTitle(tv.getName());
            show.SetCategories(tv.getGenres());
        }
        
        if(episode != null)
        {
            LOG.fine("Setting episode name and description onto show");
            show.SetEpisodeName(episode.getName());
            show.SetDescription(episode.getOverview());
        }

        if(updateCache)
        {
            LOG.fine("Updating remainder of the cache files (images, seasonImages, episodeImages) and saving the all of the cache files");
            
            Images images = TVAPI.getImages(this.request, tmdb_id, blocking);
            Images seasonImages = TVAPI.getSeasonImages(request, tmdb_id, seasonNumber, blocking);
            Images episodeImages = TVAPI.getEpisodeImages(request, tmdb_id, seasonNumber, episodeNumber, blocking);

            if(tv != null)
            {
                tv.save(detailsFile);
            }
            
            if(season != null)
            {
                season.save(seasonFile);
            }
            
            if(credits != null)
            {
                credits.save(creditsFile);
            }

            if(images.getPosters().size() > 0 || images.getBackdrops().size() > 0)
            {
                images.save(imagesFile);
            }
            
            if(episodeImages.getPosters().size() > 0)
            {
                episodeImages.save(episodeImagesFile);
            }
            
            if(seasonImages.getPosters().size() > 0)
            {
                seasonImages.save(seasonImagesFile);
            }
            
        }
        
        LOG.fine("Updating default images for the episode (Posters, Backdrops, Season Poster, Episode Still)");
        this.GetPoster(blocking);
        this.GetBackdrop(blocking);
        this.GetSeasonPoster(blocking);
        this.GetEpisodeStill(blocking);
    }
    
    /**
     * Saves key metadata to TV show, and manages cache and images for the show.
     * Will automatically retrieve any missing details for an episode.  Can force
     * a cache refresh if requested.  This call is for episodes that 
     * do not have a season episode number.
     * 
     * @param tmdb_id The Movie DB id for the TV show
     * @param forceRefresh Force refresh even if the episode is cached 
     * @param blocking Wait for the lookups to return even if a rate limiting is hit
     * @throws IOException Error reading writing to file or TMDB web service
     * @throws SageCallApiException Error calling SageAPI 
     */
    private void SaveTVMetadata(int tmdb_id, boolean forceRefresh, boolean blocking) throws IOException, SageCallApiException, RateLimitException
    {
        LOG.log(Level.INFO, "Saving TV show metadata tmdb_id for a show without episode number: {0}, forceRefresh: {1}, blocking: {2}", new Object[]{tmdb_id, forceRefresh, blocking});
        File detailsFile = this.GetTVDetailsFile(tmdb_id);
        File creditsFile = this.GetTVCreditsFile(tmdb_id);
        File imagesFile = this.GetTVImagesFile(tmdb_id);
        
        boolean updateCache = forceRefresh;
        
        //Check to see if we need to update files. If we are missing anything than update it all.
        if(!detailsFile.exists()) 
        {
            LOG.fine("Detail file does not exist, updating cache");
            updateCache = true; 
        }
        
        if(!creditsFile.exists()) 
        { 
            LOG.fine("Credits file does not exist, updating cache");
            updateCache = true; 
        }
        
        if(!imagesFile.exists()) 
        { 
            LOG.fine("Images file does not exist, updating cache");
            updateCache = true; 
        }
    
        Date now = new Date();
        
        TV tv = null;
        Credits credits = null;
            
        if(updateCache)
        {            
            tv = TVAPI.getDetails(this.request, tmdb_id, blocking);
            
            LOG.fine("Getting TV show credits from tmdb");
            credits = TVAPI.getCredits(request, tmdb_id, blocking);
        }
        else
        {
            tv = TV.parse(detailsFile, ConfigAPI.getConfig(request, blocking));
        }

        LOG.fine("Setting metadata key data onto show, and setting MediaType to TV");
        show.SetTheMovieDBID(tmdb_id);
        show.SetMetadataUpdateDate(now.getTime());
        show.SetMediaType("TV");
        
        if(tv != null)
        {
            LOG.fine("Setting title and Catefories/Genres onto show");
            show.SetTitle(tv.getName());
            show.SetCategories(tv.getGenres());
        }

        if(updateCache)
        {
            LOG.fine("Updating remainder of the cache files (images, seasonImages, episodeImages) and saving the all of the cache files");
            
            Images images = TVAPI.getImages(this.request, tmdb_id, blocking);

            if(tv != null)
            {
                tv.save(detailsFile);
            }
            
            if(credits != null)
            {
                credits.save(creditsFile);
            }
            
            if(images.getPosters().size() > 0 || images.getBackdrops().size() > 0)
            {
                images.save(imagesFile);
            }
            
        }
  
        LOG.fine("Updating default images for the episode (Posters, Backdrops, Season Poster, Episode Still)");        
        this.GetPoster(blocking);
        this.GetBackdrop(blocking);
    }
    
    /***
     * Saves key metadata to movie, and manages cache and images for the movie.
     * Will automatically retrieve any missing details for a movie.  Can force
     * a cache refresh if requested.  
     * 
     * @param tmdb_id The Movie DB id for the TV show
     * @param forceRefresh Force refresh even if the episode is cached 
     * @param blocking Wait for the lookups to return even if a rate limiting is hit
     * @throws IOException Error reading writing to file or TMDB web service
     * @throws SageCallApiException Error calling SageAPI 
     */
    public void SaveMovieMetadata(int tmdb_id, boolean forceRefresh, boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        LOG.log(Level.INFO, "Saving movie metadata tmdb_id for a show without: {0}, forceRefresh: {1}, blocking: {2}", new Object[]{tmdb_id, forceRefresh, blocking});
        
        File detailsFile = this.GetMovieDetailsFile(tmdb_id);
        File imagesFile = this.GetMovieImagesFile(tmdb_id);
        File releasesFile = this.GetMovieReleasesFile(tmdb_id);
        File creditsFile = this.GetMovieCreditsFile(tmdb_id);
        
        boolean updateCache = forceRefresh;
        
        //Check to see if we need to update files. If we are missing anything than update it all.
        if(!detailsFile.exists()) 
        {
            LOG.fine("Detail file does not exist, updating cache");
            updateCache = true; 
        }
        if(!imagesFile.exists()) 
        {
            LOG.fine("Images file does not exist, updating cache");
            updateCache = true; 
        }
        if(!releasesFile.exists()) 
        {
            LOG.fine("Releases file does not exist, updating cache");
            updateCache = true; 
        }
        if(!creditsFile.exists()) 
        {
            LOG.fine("Credits file does not exist, updating cache");
            updateCache = true; 
        }
        
        Date now = new Date();
        
        Movie movie = null;
        MovieReleases releases = null;
        Images images = null;
        Credits credits = null;
        
        if(updateCache)
        {
            movie = MovieAPI.getDetails(request, tmdb_id, blocking);
            releases = MovieAPI.getReleases(request, tmdb_id, blocking);
            images = MovieAPI.getImages(request, tmdb_id, blocking);
            credits = MovieAPI.getCredits(request, tmdb_id, blocking);
        }
        else
        {
            movie = Movie.parse(detailsFile, ConfigAPI.getConfig(request, blocking));
        }
        
        LOG.fine("Saving key metadata on movie and setting mediatype to Movie");
        show.SetTheMovieDBID(tmdb_id);
        show.SetMediaType("Movie");
        
        if(movie != null)
        {
            LOG.fine("Saving metadata on movie (Title, Description. Overview, Genres, Release Year)");
            show.SetTitle(movie.getTitle());
            show.SetDescription(movie.getOverview());
            show.SetCategories(movie.getGenres());
            show.SetYear(movie.getReleaseYear());
            show.SetMetadataUpdateDate(now.getTime());
        }
        
        if(updateCache)
        {
            LOG.fine("Saving movie cache files");
            if(movie != null)
            {
                movie.save(detailsFile);
            }

            if(releases != null)
            {
                releases.save(releasesFile);
            }

            if(credits != null)
            {
                credits.save(creditsFile);
            }

            if(images.getPosters().size() > 0 || images.getBackdrops().size() > 0)
            {
                images.save(imagesFile);
            }
        }
        
        LOG.fine("Saving default image files (Poster, Backdrop)");
        this.GetPoster(blocking);
        this.GetBackdrop(blocking);
    }

    /***
     * Get the metadata override file.  This file is used to override some of the
     * default values like posters and backdrops for a movie of show
     * 
     * @return Properties file for tv show or movie or null if there was an error
     * getting the file
     */
    private Properties GetMetadataOverrides()
    {
        Properties overrides = new Properties();
        File overridesFile;
        
        InputStream input = null;
        
        try
        {
            if(this.HasMetadata())
            {
                if(this.show.GetMediaType().equalsIgnoreCase("TV"))
                {
                    overridesFile = this.GetTVOverridesFile(show.GetTheMovieDBID());

                    if(overridesFile.exists())
                    {
                        input = new FileInputStream(overridesFile);
                        overrides.load(input);
                    }
                }
                else if(this.show.GetMediaType().equalsIgnoreCase("Movie"))
                {
                    overridesFile = this.GetMovieOverridesFile(show.GetTheMovieDBID());
                    
                    if(overridesFile.exists())
                    {
                        input = new FileInputStream(overridesFile);
                        overrides.load(input);
                    }
                }
            }
        }
        catch(Exception ex)
        {
            LOG.log(Level.WARNING, "There was an error getting the metadata override file for object: {0}", ex.getMessage());
        }
        
        return overrides;
    }
    
    /***
     * Save the metadata override file.  This file is used to override some of the
     * default values like posters and backdrops for a movie of show
     */
    private void SaveMetadataOverrides(Properties overrides)
    {
        
        File overridesFile;
        OutputStream output = null;
        
        try
        {
            if(this.HasMetadata())
            {
                if(this.show.GetMediaType().equalsIgnoreCase("TV"))
                {                    
                    overridesFile = this.GetTVOverridesFile(show.GetTheMovieDBID());
                    LOG.log(Level.FINE, "Saving metadata override file to path: {0}", overridesFile.getAbsolutePath());
                    
                    output = new FileOutputStream(overridesFile);
                    overrides.store(output, "");
                }
                else if(this.show.GetMediaType().equalsIgnoreCase("Movie"))
                {
                    overridesFile = this.GetMovieOverridesFile(show.GetTheMovieDBID());
                    LOG.log(Level.FINE, "Saving metadata override file to path: {0}", overridesFile.getAbsolutePath());
        
                    output = new FileOutputStream(overridesFile);
                    overrides.store(output, "");
                }
            }
        }
        catch(Exception ex)
        {
            LOG.log(Level.WARNING, "There was an error saving the metadata override file for object", ex);
        }
    }
    
    /**
     * Determines if there was a successful metadata lookup, and there is and TheMovieDB ID set 
     * @return True if lookup was successful
     * @throws SageCallApiException 
     */
    public boolean HasMetadata() throws SageCallApiException
    {
        LOG.log(Level.FINE, "Called HasMetadata");
        
        int tmdb = this.show.GetTheMovieDBID();
        
        LOG.log(Level.FINE, "GetTheMovieDBID returned {0}", tmdb);
        
        return (this.show.GetTheMovieDBID() > 0);
    }
    
    /***
     * Returns all of the listed releases for this movie.  If the file is missing 
     * than a lookup and caching of the data will automatically occur
     * 
     * @return Returns a MovieReleases object
     * @throws SageCallApiException Error calling SageAPI
     * @throws IOException Error reading writing to file or TMDB web service
     * @throws RateLimitException TMDB rate limit exception thrown
     */
    public MovieReleases GetMovieReleases() throws SageCallApiException, IOException, RateLimitException
    {
        LOG.fine("Getting movie releases");
        File file = this.GetMovieReleasesFile(this.show.GetTheMovieDBID());
        MovieReleases releases;
        
        if(!file.exists())
        {
            LOG.fine("Calling TheMovieDB to get releases, Releases file was not in the cache");
            releases = MovieAPI.getReleases(request, this.show.GetTheMovieDBID(), true);
            releases.save(file);
        }
        else
        {
            LOG.fine("Get releases from cache");
            releases = MovieReleases.parse(file, ConfigAPI.getConfig(request, true));
        }
        
        return releases;
    }
    
    public Credits GetMovieCredits() throws IOException, RateLimitException, SageCallApiException
    {
        File file = this.GetMovieCreditsFile(show.GetTheMovieDBID());
        Credits credits = null;
        
        if(!file.exists())
        {
            credits = MovieAPI.getCredits(this.request, this.show.GetTheMovieDBID(), true);
            credits.save(file);
        }
        else
        {
            credits = Credits.parse(file, ConfigAPI.getConfig(request, true));
        }
        
        return credits;
    }

    public Movie GetMovieDetails() throws IOException, RateLimitException, SageCallApiException
    {
        File detailsFile = this.GetMovieDetailsFile(show.GetTheMovieDBID());
        Movie movie = null;
        
        if(!detailsFile.exists())
        {
            movie = MovieAPI.getDetails(this.request, this.show.GetTheMovieDBID(), true);
            movie.save(detailsFile);
        }
        else
        {
            movie = Movie.parse(detailsFile, ConfigAPI.getConfig(request, true));
        }
        
        return movie;
    }
    
    public TV GetShowDetails() throws IOException, RateLimitException, SageCallApiException
    {
        File detailsFile = this.GetTVDetailsFile(show.GetTheMovieDBID());
        
        TV tv = null;

        if(!detailsFile.exists())
        {
            tv = TVAPI.getDetails(this.request, this.show.GetTheMovieDBID(), true);
        }
        else
        {
            tv = TV.parse(detailsFile, ConfigAPI.getConfig(request, true));
        }
        
        return tv;
    }
    
    public Credits GetShowCredits() throws IOException, RateLimitException, SageCallApiException
    {
        File detailsFile = this.GetTVCreditsFile(show.GetTheMovieDBID());
        
        Credits credits = null;

        if(!detailsFile.exists())
        {
            credits = TVAPI.getCredits(this.request, this.show.GetTheMovieDBID(), true);
        }
        else
        {
            credits = Credits.parse(detailsFile, ConfigAPI.getConfig(request, true));
        }
        
        return credits;
    }
    
    public Watched GetWatchedDetails() throws SageCallApiException, IOException
    {
        if(this.show.IsTV())
        {
            return Watched.constructModel(this.GetTVWatchedFileFile(this.show.GetTheMovieDBID(), this.show.GetSeasonNumber(), this.show.GetEpisodeNumber()));
        }
        else
        {
            return Watched.constructModel(this.GetMovieWatchedFile(show.GetTheMovieDBID()));
        }
    }
    
    public Episode getEpisodeDetails() throws IOException, RateLimitException, SageCallApiException
    {
        return this.getSeasonDetails().getEpisode(this.show.GetEpisodeNumber());
    }
    
    public Season getSeasonDetails() throws IOException, RateLimitException, SageCallApiException
    {
        File detailsFile = this.GetTVSeasonFile(show.GetTheMovieDBID(), this.show.GetSeasonNumber());

        Season season = null;

        if(!detailsFile.exists())
        {
            season = TVAPI.getSeasonDetails(this.request, this.show.GetTheMovieDBID(), this.show.GetSeasonNumber(), true);
            season.save(detailsFile);
        }
        else
        {
            season = Season.parse(detailsFile, ConfigAPI.getConfig(request, true));
        }
        
        return season;
    }

    public String GetPosterRealtime() throws SageCallApiException, IOException, RateLimitException
    {
        String ret = "";
        
        ret = this.GetPosterRealtime(false);
        
        return ret;
    }
    
    public String GetPosterRealtime(boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        return this.GetPosterRealtime(DEFAULT_POSTER_SIZE_WIDTH, blocking);
    }
    
    public String GetPosterRealtime(int preferredSize, boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        int tmdb_id = -1;
        String MediaType;
        SearchResults results;
        File file = null;
        
        LOG.log(Level.INFO, "GetPosterRealtime PreferedSize: {0} Blocking: {1}", new Object[] {preferredSize, blocking});
        
        
        if(this.show.IsMovie())
        {
            System.out.println("JVL - Looking up movie");
            int year = -1;    
            MediaType = "Movie";
        
            try { year = Integer.parseInt(this.show.GetYear()); } catch (Exception ex) { } 
            
            if(year > 0)
            {
                if(this.HasCachedMovieTMDB_ID(this.show.GetTitle(), year))
                {
                    System.out.println("JVL - Metadata cache hit getting movie id");
                    tmdb_id = this.GetCachedMovieTMDB_ID(this.show.GetTitle(), year);
                }
                else
                {
                    results = SearchAPI.searchMovies(this.request, this.show.GetTitle(), year, blocking);

                    if(results != null && results.getMovies().size() > 0)
                    {
                        tmdb_id = results.getMovies().get(0).getTmdbID();
                        this.PutCacheMovieTMDB_ID(this.show.GetTitle(), year, tmdb_id);
                    }
                }
            }
            else
            {
                if(this.HasCachedMovieTMDB_ID(this.show.GetTitle()))
                {
                    System.out.println("JVL - Metadata cache hit getting movie id");
                    tmdb_id = this.GetCachedMovieTMDB_ID(this.show.GetTitle());
                }
                else
                {
                    results = SearchAPI.searchMovies(this.request, this.show.GetTitle(), blocking);

                    if(results != null && results.getMovies().size() > 0)
                    {
                        tmdb_id = results.getMovies().get(0).getTmdbID();
                        this.PutCacheMovieTMDB_ID(this.show.GetTitle(), tmdb_id);
                    }
                }
            }

        }
        else
        {
            System.out.println("JVL - Looking up TV");
            MediaType = "TV";
            
            if(this.HasCachedTVTMDB_ID(show.GetTitle()))
            {
                System.out.println("JVL - Metadata cache hit on title for TV Show");
                tmdb_id = this.GetCachedTVTMDB_ID(show.GetTitle());
            }
            else
            {
                System.out.println("JVL - Metadata cache miss on TV Show: " + show.GetTitle());
                results = SearchAPI.searchTV(this.request, show.GetTitle(), blocking);

                if(results != null && results.getShows().size() > 0)
                {
                    tmdb_id = results.getShows().get(0).getTmdbID();
                    this.PutCacheTVTMDB_ID(show.GetTitle(), tmdb_id);
                    System.out.println("JVL - Metadata adding tp cache TMDB: " + tmdb_id);
                }
            }
        }
        
        if(tmdb_id > 0)
        {
            Images images = this.GetImages(tmdb_id, MediaType, blocking);
            
            if(images.getPosters().size() > 0)
            {
                System.out.println("JVL - Image found");
                String poster_width = images.getPoster().getValidSize(preferredSize);

                if(MediaType.equalsIgnoreCase("TV"))
                {
                    file = this.GetTVPoster(tmdb_id, poster_width, images.getPoster().getFileName());
                }
                else if(MediaType.equalsIgnoreCase("MOVIE"))
                {
                    file = this.GetMoviePoster(tmdb_id, poster_width, images.getPoster().getFileName());
                }

                if(file != null && !file.exists())
                {
                    images.getPoster().saveImage(file, preferredSize);
                }
            }
        }

        if(file != null)
        {
            return file.getAbsolutePath();
        }
        else
        {
            return "";
        }
        
    }
    
    public String GetBackdropRealtime()
    {
        String ret = "";
        
        try 
        {
            ret = this.GetBackdropRealtime(false);
        } 
        catch (Exception ex) 
        {
            System.out.println("JVL Metadata - Exception calling GetBackdropRealtime: " + ex.getMessage());
        } 
        
        return ret;
    }
    
    public String GetBackdropRealtime(boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        return this.GetBackdropRealtime(DEFAULT_BACKDROP_SIZE_WIDTH, blocking);
    }
    
    public String GetBackdropRealtime(int preferredSize, boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        int tmdb_id = -1;
        String MediaType;
        SearchResults results;
        File file = null;
        
        System.out.println("JVL - Realtime backdrop lookup called");
        
        if(this.show.IsMovie())
        {
            System.out.println("JVL - Looking up movie");
            int year = -1;    
            MediaType = "Movie";
        
            try { year = Integer.parseInt(this.show.GetYear()); } catch (Exception ex) { } 
            
            if(year > 0)
            {
                if(this.HasCachedMovieTMDB_ID(this.show.GetTitle(), year))
                {
                    System.out.println("JVL - Metadata cache hit getting movie id");
                    tmdb_id = this.GetCachedMovieTMDB_ID(this.show.GetTitle(), year);
                }
                else
                {
                    results = SearchAPI.searchMovies(this.request, this.show.GetTitle(), year, blocking);

                    if(results != null && results.getMovies().size() > 0)
                    {
                        tmdb_id = results.getMovies().get(0).getTmdbID();
                        this.PutCacheMovieTMDB_ID(this.show.GetTitle(), year, tmdb_id);
                    }
                }
            }
            else
            {
                if(this.HasCachedMovieTMDB_ID(this.show.GetTitle()))
                {
                    System.out.println("JVL - Metadata cache hit getting movie id");
                    tmdb_id = this.GetCachedMovieTMDB_ID(this.show.GetTitle());
                }
                else
                {
                    results = SearchAPI.searchMovies(this.request, this.show.GetTitle(), blocking);

                    if(results != null && results.getMovies().size() > 0)
                    {
                        tmdb_id = results.getMovies().get(0).getTmdbID();
                        this.PutCacheMovieTMDB_ID(this.show.GetTitle(), tmdb_id);
                    }
                }
            }

        }
        else
        {
            System.out.println("JVL - Looking up TV");
            MediaType = "TV";
            
            if(this.HasCachedTVTMDB_ID(show.GetTitle()))
            {
                System.out.println("JVL - Metadata cache hit on title for TV Show");
                tmdb_id = this.GetCachedTVTMDB_ID(show.GetTitle());
            }
            else
            {
                results = SearchAPI.searchTV(this.request, show.GetTitle(), blocking);

                if(results != null && results.getShows().size() > 0)
                {
                    tmdb_id = results.getShows().get(0).getTmdbID();
                    this.PutCacheTVTMDB_ID(show.GetTitle(), tmdb_id);
                }
            }
        }
        
        if(tmdb_id > 0)
        {
            Images images = this.GetImages(tmdb_id, MediaType, blocking);
            
            if(images.getBackdrops().size() > 0)
            {
                System.out.println("JVL - Image found");
                String backdrops_width = images.getBackdrop().getValidSize(preferredSize);

                if(MediaType.equalsIgnoreCase("TV"))
                {
                    file = this.GetTVBackdrops(tmdb_id, backdrops_width, images.getBackdrop().getFileName());
                }
                else if(MediaType.equalsIgnoreCase("MOVIE"))
                {
                    file = this.GetMovieBackdrops(tmdb_id, backdrops_width, images.getBackdrop().getFileName());
                }

                if(file != null && !file.exists())
                {
                    images.getBackdrop().saveImage(file, preferredSize);
                }
            }
        }

        if(file != null)
        {
            return file.getAbsolutePath();
        }
        else
        {
            return "";
        }
        
    }
    
    public void SetPoster(Image image)
    {
        Properties overrides = this.GetMetadataOverrides();
        
        overrides.setProperty("show.poster", image.getFileName());
        this.SaveMetadataOverrides(overrides);
    }
    
    public void SetBackdrop(Image image)
    {
        Properties overrides = this.GetMetadataOverrides();
        
        overrides.setProperty("show.backdrop", image.getFileName());
        this.SaveMetadataOverrides(overrides);
    }
    
    public void SetSeasonPoster(Image image) throws SageCallApiException
    {
        Properties overrides = this.GetMetadataOverrides();
        
        overrides.setProperty("show.season_" + this.show.GetSeasonNumber() + ".poster", image.getFileName());
        this.SaveMetadataOverrides(overrides);
    }
    
    public String GetPoster()
    {
        String ret = "";
        
        try 
        {
            ret = this.GetPoster(false);
        } 
        catch (Exception ex) 
        {
            System.out.println("JVL Metadata - Exception calling GetPoster: " + ex.getMessage());
        } 
        
        return ret;
    }
    
    /**
     * Gets the default poster for movie/show with the default size. Will download
     * and save the image into the local cache folder
     * 
     * @return Path to the locally cached poster in the default size
     * @throws SageCallApiException
     * @throws IOException 
     */
    public String GetPoster(boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        return this.GetPoster(Metadata.DEFAULT_POSTER_SIZE_WIDTH, blocking);
    }
    
    /**
     * Gets the default poster for movie/show with the closest match to the preferred size.
     * Will download and save the image into the local cache folder
     * 
     * @return Path to the locally cached file in the closest matched preferred size
     * @throws SageCallApiException
     * @throws IOException 
     */
    public String GetPoster(int preferredSize, boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        File file = null;
        Images images = null;
        Properties overrides = this.GetMetadataOverrides();
        
        if(this.HasMetadata())
        {
            images = this.GetImages(this.show.GetTheMovieDBID(), this.show.GetMediaType(), blocking);
        }
        
        if(this.HasMetadata() && images != null && images.getPosters().size() > 0)
        {
            Image image = images.getPoster(overrides.getProperty("show.poster", images.getPoster().getFileName()));
            
            if(image == null)
            {
                image = images.getPoster();
            }
            
            String poster_width = image.getValidSize(preferredSize);
            
            if(this.show.GetMediaType().equalsIgnoreCase("TV"))
            {
                file = this.GetTVPoster(show.GetTheMovieDBID(), poster_width, image.getFileName());
            }
            else if(this.show.GetMediaType().equalsIgnoreCase("MOVIE"))
            {
                file = this.GetMoviePoster(show.GetTheMovieDBID(), poster_width, image.getFileName());
            }
            
            if(file != null && !file.exists())
            {
                image.saveImage(file, preferredSize);
            }
        }
     
        if(file != null)
        {
            return file.getAbsolutePath();
        }
        else
        {
            return "";
        }
    }
    
    public ArrayList<Image> GetPosterImages()
    {
        ArrayList<Image> images = null;
        
        try 
        {
            if(this.HasMetadata())
            {
                images = this.GetImages(this.show.GetTheMovieDBID(), this.show.GetMediaType(), true).getPosters();
            }
        } 
        catch (Exception ex) 
        {
            System.out.println("JVL Metadata - Error getting poster images");
        }
        
        return images;
    }
    
    public String [] GetPosters()
    {
        String [] ret = new String[0];
        
        try 
        {
            ret = this.GetPosters(false);
        } 
        catch (Exception ex) 
        {
            System.out.println("JVL Metadata - Exception calling GetPosterRealtime: " + ex.getMessage());
        } 
        
        return ret;
    }
    
    public String [] GetPosters(boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        Images images = null;
        String [] urls = null;
        
        if(this.HasMetadata())
        {
            images = this.GetImages(this.show.GetTheMovieDBID(), this.show.GetMediaType(), blocking);
        }
        
        if(images != null && images.getPosters().size() > 0)
        {
            urls = new String [images.getPosters().size()];
            
            for(int i = 0; i < images.getPosters().size(); i++)
            {
                urls[i] = images.getPosters().get(i).getURL(DEFAULT_POSTER_SIZE_WIDTH);
            }
        }
        
        return urls;
    }
    
    public ArrayList<Image> GetSeasonPosterImages()
    {
        ArrayList<Image> images = null;
        
        try 
        {
            if(this.HasMetadata())
            {
                images = this.GetSeasonImages(this.show.GetTheMovieDBID(),this.show.GetMediaType(), this.show.GetSeasonNumber(), true).getPosters();
            }
        } 
        catch (Exception ex) 
        {
            System.out.println("JVL Metadata - Error getting poster images");
        }
        
        return images;
    }
    
    public String GetSeasonPoster()
    {
        String ret = "";
        
        try 
        {
            ret = this.GetSeasonPoster(false);
        } 
        catch (Exception ex) 
        {
            System.out.println("JVL Metadata - Exception calling GetSeasonPoster: " + ex.getMessage());
        } 
        
        return ret;
    }
    
    public String GetSeasonPoster(boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        return this.GetSeasonPoster(DEFAULT_POSTER_SIZE_WIDTH, blocking);
    }
    
    public String GetSeasonPoster(int preferredSize, boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        Properties overrides = this.GetMetadataOverrides();
        File file = null;
        Images images = null;
        
        if(this.HasMetadata())
        {
            images = this.GetSeasonImages(this.show.GetTheMovieDBID(), this.show.GetMediaType(), this.show.GetSeasonNumber(), blocking);
        }
        
        if(this.HasMetadata() && images != null && images.getPosters().size() > 0)
        {
            Image image = images.getPoster(overrides.getProperty("show.season_" + this.show.GetSeasonNumber() + ".poster", images.getPoster().getFileName()));
            
            if(image == null)
            {
                image = images.getPoster();
            }
            
            String poster_width = image.getValidSize(preferredSize);
            
            if(this.show.GetMediaType().equalsIgnoreCase("TV"))
            {
                file = this.GetTVSeasonPoster(this.show.GetTheMovieDBID(), poster_width, show.GetSeasonNumber(), image.getFileName());
                
            }
            
            if(file != null && !file.exists())
            {
                image.saveImage(file, preferredSize);
            }
        }
        
        if(file != null)
        {
            return file.getAbsolutePath();
        }
        else
        {
            return "";
        }
    }
    
    public String GetEpisodeStill()
    {
        String ret = "";
        
        try 
        {
            ret = this.GetEpisodeStill(false);
        } 
        catch (Exception ex) 
        {
            System.out.println("JVL Metadata - Exception calling GetEpisodeStill: " + ex.getMessage());
        } 
        
        return ret;
    }
    
    public String GetEpisodeStill(boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        return this.GetEpisodeStill(DEFAULT_STILL_SIZE_WIDTH, blocking);
    }
    
    public String GetEpisodeStill(int preferredSize, boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        File file = null;
        Images images = null;
        
        if(this.HasMetadata() && show.GetEpisodeNumber() > 0)
        {
            images = this.GetEpisodeImages(this.show.GetTheMovieDBID(), this.show.GetMediaType(), this.show.GetSeasonNumber(), this.show.GetEpisodeNumber(), blocking);
        }
        
        if(this.HasMetadata() && images != null && images.getStills().size() > 0)
        {
            String still_width = images.getStill().getValidSize(preferredSize);
            
            if(this.show.GetMediaType().equalsIgnoreCase("TV"))
            {
                file = this.GetTVEpisodeStill(show.GetTheMovieDBID(), still_width, show.GetSeasonNumber(), show.GetEpisodeNumber(), images.getStill().getFileName());
            }
            
            if(file != null && !file.exists())
            {
                images.getStill().saveImage(file, preferredSize);
            }
        }
        
        if(file != null)
        {
            return file.getAbsolutePath();
        }
        else
        {
            return "";
        }
    }
    
    public ArrayList<Image> GetBackdropImages()
    {
        ArrayList<Image> images = null;
        
        try 
        {
            if(this.HasMetadata())
            {
                images = this.GetImages(this.show.GetTheMovieDBID(), this.show.GetMediaType(), true).getBackdrops();
            }
        } 
        catch (Exception ex) 
        {
            System.out.println("JVL Metadata - Error getting poster images");
        }
        
        return images;
    }
    
    public String GetBackdrop()
    {
        String ret = "";
        
        try 
        {
            ret = this.GetBackdrop(false);
        } 
        catch (Exception ex) 
        {
            System.out.println("JVL Metadata - Exception calling GetBackdrop: " + ex.getMessage());
        } 
        
        return ret;
    }
    
    /**
     * Gets the default backdrop for movie/show with the default size. Will download
     * and save the image into the local cache folder
     * 
     * @return Path to the locally cached poster in the default size
     * @throws SageCallApiException
     * @throws IOException 
     */
    public String GetBackdrop(boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        return this.GetBackdrop(DEFAULT_BACKDROP_SIZE_WIDTH, blocking);
    }
    
     /**
     * Gets the default backdrop for movie/show with the closest match to the preferred size.
     * Will download and save the image into the local cache folder
     * 
     * @return Path to the locally cached file in the closest matched preferred size
     * @throws SageCallApiException
     * @throws IOException 
     */
    public String GetBackdrop(int preferredSize, boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        File file = null;
        Images images = null;
        Properties overrides = this.GetMetadataOverrides();
        
        if(this.HasMetadata())
        {
            images = this.GetImages(this.show.GetTheMovieDBID(), this.show.GetMediaType(), blocking);
        }
        
        if(this.HasMetadata() && images != null && images.getBackdrops().size() > 0)
        {
            Image image = images.getBackdrop(overrides.getProperty("show.backdrop", images.getBackdrop().getFileName()));
            
            if(image == null)
            {
                image = images.getBackdrop();
            }
            
            String backdrop_width = image.getValidSize(preferredSize);
            
            if(this.show.GetMediaType().equalsIgnoreCase("TV"))
            {
                file = this.GetTVBackdrops(show.GetTheMovieDBID(), backdrop_width, image.getFileName());
            }
            else if(this.show.GetMediaType().equalsIgnoreCase("MOVIE"))
            {
                file = this.GetMovieBackdrops(show.GetTheMovieDBID(), backdrop_width, image.getFileName());
            }
            
            if(file != null && !file.exists())
            {
                image.saveImage(file, preferredSize);
            }
        }
        
        if(file != null)
        {
            return file.getAbsolutePath();
        }
        else
        {
            return "";
        }
    }
    
    private Images GetSeasonImages(int TheMovieDBID, String MediaType, int seasonNumber, boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        Images images = null;
        
        if(MediaType.equalsIgnoreCase("TV"))
        {
            File imagesFile = this.GetTVSeasonImagesFile(TheMovieDBID, seasonNumber);
            
            if(imagesFile.exists())
            {
                images = Images.parse(imagesFile, ConfigAPI.getConfig(this.request, blocking));
                
                if(images.getPosters().isEmpty())
                {
                    images = TVAPI.getSeasonImages(request, TheMovieDBID, seasonNumber, blocking);
                    
                    if(images != null)
                    {
                        images.save(imagesFile);
                    }
                }
            }
            else
            {
                images = TVAPI.getSeasonImages(request, TheMovieDBID, seasonNumber, blocking);
                
                if(images != null)
                {
                    images.save(imagesFile);
                }
            }
        }
        
        return images;
    }
    
    private Images GetEpisodeImages(int TheMovieDBID, String MediaType, int seasonNumber, int episodeNumber, boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        Images images = null;
        
        if(MediaType.equalsIgnoreCase("TV"))
        {
            File imagesFile = this.GetTVEpisodeImagesFile(TheMovieDBID, seasonNumber, episodeNumber);
            
            if(imagesFile.exists())
            {
                images = Images.parse(imagesFile, ConfigAPI.getConfig(this.request, blocking));
                
                if(images.getStills().isEmpty())
                {
                    images = TVAPI.getEpisodeImages(this.request, TheMovieDBID, seasonNumber, episodeNumber, blocking);
                    
                    if(images != null)
                    {
                        images.save(imagesFile);
                    }
                }
            }
            else
            {
                images = TVAPI.getEpisodeImages(this.request, TheMovieDBID, seasonNumber, episodeNumber, blocking);
                
                if(images != null)
                {
                    images.save(imagesFile);
                }
            }
        }
        
        return images;
    }
    
    private Images GetImages(int TheMovieDBID, String MediaType, boolean blocking) throws SageCallApiException, IOException, RateLimitException
    {
        Images images = null;
        
        
        if(MediaType.equalsIgnoreCase("TV"))
        {
            File imagesFile = this.GetTVImagesFile(TheMovieDBID);

            if(imagesFile.exists())
            {
                images = Images.parse(imagesFile, ConfigAPI.getConfig(this.request, blocking));
                
                if(images.getBackdrops().isEmpty() || images.getPosters().isEmpty())
                {
                    images = TVAPI.getImages(request, TheMovieDBID, blocking);
                    
                    if(images != null)
                    {
                        images.save(imagesFile);
                    }
                }
            }
            else
            {
                images = TVAPI.getImages(request, TheMovieDBID, blocking);
                
                if(images != null)
                {
                    images.save(imagesFile);
                }
            }
        }
        else if(MediaType.equalsIgnoreCase("MOVIE"))
        {
            File imagesFile = this.GetMovieImagesFile(TheMovieDBID);

            if(imagesFile.exists())
            {
                images = Images.parse(imagesFile, ConfigAPI.getConfig(this.request, blocking));
                
                if(images.getBackdrops().isEmpty() || images.getPosters().isEmpty())
                {
                    images = MovieAPI.getImages(request, TheMovieDBID, blocking);
                   
                    if(images != null)
                    {
                        images.save(imagesFile);
                    }
                }

            }
            else
            {
                images = MovieAPI.getImages(request, TheMovieDBID, blocking);
                
                if(images != null)
                {
                    images.save(imagesFile);
                }
            }
        }
        
        
        return images;
    }
    
   // <editor-fold defaultstate="collapsed" desc="File Path Builder Methods for data cache">
    
    /*
    *  Directory Structure for cache folders
    *      Root ->
    *              movies ->
    *                      [TMDB ID] ->
    *                                  details.json
    *                                  images.json
                                       releases.json
                                       credits.json
    *                                  posters ->
    *                                              size ->
    *                                                      name.jpg
    *                                  backdrops ->
    *                                              size ->
    *                                                      name.jpg
    *
    *      Root ->
    *              TV ->
    *                      {TMDB ID} ->
    *                                  details.json
    *                                  credits.json 
    *                                  images.json
    *                                  posters (Show) ->
    *                                                  size ->
                                                               name.jpg
    *                                  backdrops (Show) ->
    *                                                  size ->
                                                               name.jpg
    *                                  season_{n} ->
    *                                                  season.json
    *                                                  posters ->
    *                                                              size ->
                                                                           name.jpg
    *                                                  episode_{n} ->
                                                                       stills
               *                                                              size ->
    *                                                                                  name.jpg
    *  Directory Structure for data folders
    *      Root ->
    *              movies ->
    *                      [TMDB ID] ->
    *                                  watched.json
    *
    *      Root ->
    *              TV ->
    *                      {TMDB ID} ->
    *                                  season_{n} ->
    *                                                  episode_{n} ->
                                                                       watched.json
    *
   */

    
    private File GetTVDetailsFile(int tmdb_id)
    {
        //TODO: Rename details.json to the proper name
        return new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/detials.json");
    }
    
    private File GetTVCreditsFile(int tmdb_id)
    {
        //TODO: Rename details.json to the proper name
        return new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/credits.json");
    }
    
    private File GetTVOverridesFile(int tmdb_id)
    {
        return new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/overrides.properties");
    }
 
    private File GetTVImagesFile(int tmdb_id)
    {
        return new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/images.json");
    }
    
    private File GetTVSeasonFile(int tmdb_id, int seasonNumber)
    {
        return new  File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/season_" + seasonNumber + "/season.json");
    }
    
    private File GetTVSeasonImagesFile(int tmdb_id, int seasonNumber)
    {
        return new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/season_" + seasonNumber + "/images.json"); 
    }
    
    private File GetTVEpisodeImagesFile(int tmdb_id, int seasonNumber, int episodeNumber)
    {
        return new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/season_" + seasonNumber + "/episode_" + episodeNumber + "/images.json");
    }
    
    private File GetTVWatchedFileFile(int tmdb_id, int seasonNumber, int episodeNumber)
    {
        return new  File(this.dataFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/season_" + seasonNumber + "/episode_" + episodeNumber + "/watched.json");
    }
    
    private File GetTVPoster(int tmdb_id, String width, String fileName)
    {
        return new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/posters/" + width + fileName);
    }
    
    private File GetTVBackdrops(int tmdb_id, String width, String fileName)
    {
        return new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/backdrops/" + width + fileName);
    }
    
    private File GetTVSeasonPoster(int tmdb_id, String width, int seasonNumber, String fileName)
    {
        return new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/season_" + seasonNumber + "/posters/" + width + fileName);
    }
    
    private File GetTVEpisodeStill(int tmdb_id, String width, int seasonNumber, int episodeNumber, String fileName)
    {
        return new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/season_" + seasonNumber + "/episode_" + episodeNumber + "/stills/" + width + fileName);
    }
    
    
    private File GetMovieDetailsFile(int tmdb_id)
    {
        //TODO: Rename details.json to the proper name
        return new File(this.cacheFolder.getAbsolutePath() + "/movies/" + tmdb_id + "/detials.json");
    }
    
    private File GetMovieWatchedFile(int tmdb_id)
    {
        //TODO: Rename details.json to the proper name
        return new File(this.dataFolder.getAbsolutePath() + "/movies/" + tmdb_id + "/watched.json");
    }
    
    private File GetMovieReleasesFile(int tmdb_id)
    {
        //TODO: Rename details.json to the proper name
        return new File(this.cacheFolder.getAbsolutePath() + "/movies/" + tmdb_id + "/releases.json");
    }
    
    private File GetMovieCreditsFile(int tmdb_id)
    {
        //TODO: Rename details.json to the proper name
        return new File(this.cacheFolder.getAbsolutePath() + "/movies/" + tmdb_id + "/credits.json");
    }
    
    private File GetMovieOverridesFile(int tmdb_id)
    {
        return new File(this.cacheFolder.getAbsolutePath() + "/movies/" + tmdb_id + "/overrides.properties");
    }
    
    private File GetMovieImagesFile(int tmdb_id)
    {
        return new File(this.cacheFolder.getAbsolutePath() + "/movies/" + tmdb_id + "/images.json");
    }
    
    private File GetMoviePoster(int tmdb_id, String width, String fileName)
    {
        return new File(this.cacheFolder.getAbsolutePath() + "/movies/" + tmdb_id + "/posters/" + width + fileName);
    }
    
    private File GetMovieBackdrops(int tmdb_id, String width, String fileName)
    {
        return new File(this.cacheFolder.getAbsolutePath() + "/movies/" + tmdb_id + "/backdrops/" + width + fileName);
    }
    
    /*
    --TV Data File Locations
    File detailsFile = new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/detials.json");
    File imagesFile = new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/images.json");
    File seasonFile = new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/season_" + seasonNumber + "/season.json");
    File seasonImagesFile = new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/season_" + seasonNumber + "/images.json");
    File episodeImagesFile = new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/season_" + seasonNumber + "/episode_" + episodeNumber + "/images.json");

    overridesFile = new File(this.cacheFolder.getAbsolutePath() + "/tv/" + show.GetTheMovieDBID() + "/overrides.properties");

    File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/posters/" + poster_width + images.getPoster().getFileName());
    file = new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/backdrops/" + backdrops_width + images.getBackdrop().getFileName());
    file = new File(this.cacheFolder.getAbsolutePath() + "/tv/" + this.show.GetTheMovieDBID() + "/season_" + this.show.GetSeasonNumber() + "/posters/" + poster_width + image.getFileName());
    file = new File(this.cacheFolder.getAbsolutePath() + "/tv/" + this.show.GetTheMovieDBID() + "/season_" + this.show.GetSeasonNumber() + "/episode_" + this.show.GetEpisodeNumber() + "/stills/" + still_width + images.getStill().getFileName());



    --Movie Data File Locations

    overridesFile = new File(this.cacheFolder.getAbsolutePath() + "/movies/" + show.GetTheMovieDBID() + "/overrides.properties");

    File detailsFile = new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/detials.json");
    File imagesFile = new File(this.cacheFolder.getAbsolutePath() + "/tv/" + tmdb_id + "/images.json");


    File detailsFile = new File(this.cacheFolder.getAbsolutePath() + "/movies/" + tmdb_id + "/detials.json");
    File imagesFile = new File(this.cacheFolder.getAbsolutePath() + "/movies/" + tmdb_id + "/images.json");


    File(this.cacheFolder.getAbsolutePath() + "/movies/" + tmdb_id + "/posters/" + poster_width + images.getPoster().getFileName());
    file = new File(this.cacheFolder.getAbsolutePath() + "/movies/" + tmdb_id + "/backdrops/" + backdrops_width + images.getBackdrop().getFileName());
    
    */
    
    
    // </editor-fold>
}